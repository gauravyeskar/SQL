use mobile_db;
select * from sm;
-- Rank():-
-- Write a query to rank all smartphones based on their Rating globally, from highest to lowest.
select brand_name, model,rating,rank()over(order by rating desc) as rnk from sm;

-- Rank all phones within each Brand based on their Price (lowest price gets rank 1).
select brand_name,price,rank()over(partition by brand_name order by price asc) as Price_RNK from sm;

-- Find the top 5 highest-rated smartphones overall using Rank().
with cte as ( select brand_name,price,rating,rank() over(order by rating desc) as rnk from sm)
select brand_name,price,rating,rnk from cte where rnk <=5 ; 

-- Partition the data by Brand and rank phones by Rating. Filter the result to show only phones ranked 3 or better within their brand.
with cte as (select brand_name,Rating,rank()over(partition by brand_name order by rating desc) as rnk from sm) 
select brand_name,rating,rnk from cte where rnk<=3;

-- Rank phones based on Price globally. If two phones have the same price, they should have the same rank.
select brand_name,price,rank()over(order by price desc) as rnk from sm;

-- Display the Model Name and Brand for all phones that tie for the highest Rating (Rank 1) across the entire dataset.
with cte as (select brand_name,model,rating,rank()over(order by rating desc) as rnk from sm) 
select brand_name,model,rating,rnk from cte where rnk = 1;

-- Rank the phones in the 'Xiaomi' brand by Price in ascending order.
select brand_name,price,rank()over(order by price) as rnk from sm where brand_name = 'Xiaomi'; 

-- Rank all phones based on the combination of Rating (descending) and Price (ascending).
with cte as( select brand_name,price,rating,rank()over(order by rating desc,price asc) as rnk from sm) 
select brand_name,price,rating,rnk from cte;

-- Find the highest-priced phone for each brand and assign it Rank 1, using Rank().
select brand_name,price,rank() over(partition by brand_name order by price desc) as rnk from sm;

-- Write a query to find the rank of a specific model (e.g., 'Xiaomi 14') based on its Rating globally.
with cte as ( select brand_name, model, rating,rank()over(order by rating desc) as rnk from sm) 
select brand_name, model, rating,rnk from cte where model = "Xiaomi 14";

-- ############################################################################################################################################################
-- Dense_Rank():- 
-- Write a query to assign a dense rank to all smartphones based on their Rating globally, from highest to lowest.
select brand_name,price,rating,dense_rank() over(order by rating desc) as drnk from sm;

-- What is the difference in the maximum rank assigned by RANK() vs DENSE_RANK() when ranking phones by Price globally?
with cte as ( select brand_name,model,price,rank() over(order by price desc) as rnk, dense_rank() over(order by price desc) as drnk from sm)
select max(rnk) as max_rnk,max(drnk) as max_denk,(max(rnk) - max(drnk)) as diff from cte;

-- Partition the data by Brand and use DENSE_RANK() to rank phones by Rating.
select brand_name,price,rating ,dense_rank() over(partition by brand_name order by rating desc) as drnk from sm;

-- Find the top 3 distinct rating levels DENSE RANK() across the entire dataset.
with dist as( select distinct(rating) from sm), 
drnk as (select rating,dense_rank() over(order by rating desc) as drnk from dist) 
select rating as top_rating, drnk from drnk where drnk <= 3;	

-- List all phones that share the 2nd best dense rank in terms of Price within the 'ZTE' brand.
with cte as ( select brand_name,price,dense_rank() over(order by price desc)as drnk from sm where brand_name = 'ZTE')
select brand_name,price,drnk from cte where drnk = 2;

-- Use Dense_Rank() to identify the second-highest Price point overall.
with cte as (select brand_name,price,dense_rank() over(order by price desc) as drnk from sm)
select brand_name,price,drnk from cte where drnk = 2;

-- Display the Brand, Model Name, and the dense rank based on Rating, but only for phones with a rank of 5 or less.
with cte as (select brand_name,model,rating,dense_rank()over(order by rating desc) as  drnk from sm)
select brand_name,model,rating,drnk from cte where drnk <=5;

-- Compare the results of Rank() and Dense_Rank() side-by-side for the top 10 phones by Price.
with cte as ( select brand_name,model,price,rank() over(order by price desc) as rnk, dense_rank() over(order by price desc) as drnk,row_number()over(order by price desc)as rn from sm) 
select rn,brand_name,model,price,rnk,drnk from cte where rn <= 10;

-- Rank phones densely by Rating within the 'Samsung' brand.
select brand_name,rating,dense_rank()over(order by rating desc) as drnk from sm where brand_name = 'Samsung';

-- How many distinct rank numbers are generated by Dense_Rank() when partitioning by Brand and ordering by Price?
with cte as (select brand_name,price,dense_rank() over(partition by brand_name order by price desc) as drnk from sm) 
select count(distinct(drnk)) from cte;

-- ##############################################################################################################################################################
-- Row_Number():- 
-- Assign a unique, sequential row number to every phone when ordered by Price in descending order.
select brand_name,price,row_number() over(order by price desc) as rn from sm;

-- Partition the data by Brand and assign a sequential row number to each phone based on its Rating (highest rating first).
select brand_name,price,row_number() over(partition by brand_name order by rating desc) as rn from sm;

-- Select the single best-rated phone (Row Number 1) for every Brand.
with cte as (select brand_name,price,rating,row_number() over(partition by brand_name order by rating desc) as rn from sm)
select brand_name,price,rating,rn from cte where rn = 1;

-- Retrieve the 5th phone model listed alphabetically within the 'Xiaomi' brand using Row_Number().
with cte as (select brand_name,model,price,row_number() over(order by model) as rn from sm where brand_name = 'Xiaomi')
select brand_name,model,price,rn from cte where rn = 5;

-- Assign a row number to all phones, ordered alphabetically by Model_Name.
select model,price,row_number() over(order by model) as rn from sm;

-- Use row_Number to identify the 3 most expensive phones overall.
with cte as ( select brand_name,price,row_number() over(order by price desc) as rn from sm) 
select brand_name,price,rn from cte where rn <=3 ;

-- Write a query to show the Model Name, Brand, and a sequential number for all phones in the 'Samsung' brand, ordered by Rating.
select brand_name,model,rating,row_number() over(order by rating desc) as rn from sm where brand_name = "Samsung";

-- How can ROW_NUMBER() be used in a subquery to implement pagination (e.g., showing rows 11 through 20 of all phones 
-- ordered by price)?
with cte as (select brand_name,model,price,row_number()over(order by price desc) as rn from sm ) 
select brand_name,model,price,rn from cte where rn between 11 and 20;

-- Assign a unique row number to phones partitioned by the first letter of their Model_Name.
select brand_name,model,price,left(model,1) as first_ltr,row_number() over(partition by left(model,1) order by price desc) as rn from sm;

-- Find the difference between the Row Number based on ascending Price and the Row Number based on ascending Rating 
-- each phone.
select brand_name,model,price,rating,row_number()over(order by price) as rn1,row_number()over(order by rating)as rn2,
(row_number()over(order by price asc) - row_number()over(order by rating asc))as diff from sm;

-- ############################################################################################################################################################
-- First_Value():- 
-- Write a query to display the lowest Price (the first value when ordering by price ascending) for the entire dataset next to every phone's price.
select brand_name,price,first_value(price)over(order by price) as fv from sm;

-- For each phone, display the highest Rating available within its Brand.
select brand_name,rating,first_value(rating)over(partition by brand_name order by rating desc)as fv from sm;

-- Display the Model_Name of the most expensive phone within each Brand.
select model,price,first_value(model)over(partition by brand_name order by price desc)as fv from sm;

-- Find the Brand name of the phone with the highest overall Rating and display it in a column next to all other rows.
select brand_name,price,rating,first_value(brand_name)over(order by rating desc)as fv from sm;

-- What is the Price of the first phone encountered when partitioning by Brand and ordering by Model_Name alphabetically?
select brand_name,price,first_value(price)over(partition by brand_name order by model )as fv from sm;

-- Write a query to see the price of the first phone released by a brand (ordered by a hypothetical Release_Date 
-- column, which you can simulate by ordering by Model_Name ascending).
select brand_name,price,first_value(brand_name)over(order by model) as fv from sm;

-- Calculate the difference between each phone's Price and the cheapest phone's price in its respective Brand.
select brand_name,price,max(price)over(partition by brand_name order by price desc) as max_price,min(price)over(partition by brand_name order by price asc) as min_price,
(max(price)over(partition by brand_name )-min(price)over(partition by brand_name )) as diff from sm;

-- For the 'Xiaomi' brand, use Row_Number to show the Rating of their best-rated phone next to every phone's row.
select brand_name,model,rating,first_value(rating)over(order by rating desc) as fv from sm where brand_name = 'Xiaomi';

-- Find the Model_Name of the highest-rated phone when considering only phones within the current row's preceding
-- 5 rows (frame definition: ROWS BETWEEN 5 PRECEDING AND CURRENT ROW).
select model,rating,first_value(model)over(order by rating desc rows between 5 preceding and Current row)as fv from sm;

-- Use First_Value to display the lowest Price within the entire table, regardless of partitioning.
select brand_name,price,first_value(price)over(order by price asc) as fv from sm;

-- ############################################################################################################################################################
-- Last_Value():-
-- Display the highest Price (the last value when ordering by price ascending) for the entire dataset next to every phone's price. (Requires specific frame definition).
select brand_name,price,last_value(price)over(order by price rows between unbounded preceding and unbounded following)as lv from sm;

-- For each phone, display the lowest Rating (the last value when ordering by rating descending) available
--  within its Brand.
select brand_name,rating,last_value(rating)over(partition by brand_name order by rating desc
 rows between unbounded preceding and unbounded following)as lv from sm;

-- Display the Model_Name of the least expensive phone within each Brand.
select brand_name,model,price,last_value(model)over(partition by brand_name order by price desc rows between unbounded preceding and unbounded following) as lv from sm;

-- Find the Brand name of the phone with the lowest overall Rating and display it in a column next to all other rows.
select brand_name,rating,last_value(brand_name) over(order by rating desc rows between unbounded preceding and unbounded following) as lv from sm;

-- What is the Rating of the last phone encountered when partitioning by Brand and ordering by Model_Name alphabetically?
select brand_name,model,rating,last_value(rating)over(partition by brand_name order by model rows between unbounded preceding and unbounded following) as lv from sm;

-- Use Last_Value() with a frame of ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING to retrieve the highest Price globally.
select brand_name,model,price,last_value(price)over(order by price rows between unbounded preceding and unbounded following) as lv from sm;

-- Calculate the difference between each phone's Price and the most expensive phone's price in its respective Brand.
select brand_name,price,last_value(price)over(partition by brand_name order by price rows between unbounded preceding and unbounded following) as lv,
(last_value(price)over(partition by brand_name order by price rows between unbounded preceding and unbounded following) - price) as diff from sm;

-- For the 'Samsung' brand, use Last_Value() to show the Price of their most expensive phone (when ordering by Price ascending) next to every phone's row.
select model,price,last_value(price)over(order by price rows between unbounded preceding and unbounded following)as
 lv from sm where brand_name='Samsung' order by price desc;

-- Find the Model_Name of the lowest-rated phone when considering only phones within the current row's succeeding 
-- 5 rows (frame definition: ROWS BETWEEN CURRENT ROW AND 5 FOLLOWING).
select brand_name,model,rating,last_value(model)over(order by rating rows between current row and 5 following) as lv from sm;

-- Write a query to see the Price of the last phone listed in the data after ordering all phones by Rating descending.
select brand_name,price,rating,last_value(price)over(order by rating desc rows between unbounded preceding and unbounded following) as lv from sm;

-- ##############################################################################################################################################################
-- Nth_Value():- 
-- Write a query to display the Model_Name of the 3rd highest-rated phone overall.
select brand_name,model,price,nth_value(model,3)over(order by rating desc) as nv from sm;

-- For each phone, display the Price of the 2nd cheapest phone within its Brand.
select brand_name,price,nth_value(price,2)over(partition by brand_name order by price rows between unbounded preceding and unbounded following) as nv from sm;

-- Find the Rating of the phone that ranks 4th by price (descending) across the entire dataset.
select brand_name,price,rating,nth_value(rating,4)over(order by price desc rows between unbounded preceding and unbounded following)as nv from sm order by rating desc;

-- Partition the data by Brand and find the Model_Name of the 5th phone when ordered alphabetically by Model_Name within that brand.
select brand_name,model,nth_value(model,5)over(partition by brand_name order by model desc rows between unbounded preceding and unbounded following) as nv from sm;

-- Use Nth_VALUE() to find the Price of the 2nd most expensive phone for each brand.
select brand_name,price,nth_value(price,2)over(partition by brand_name order by price desc rows between unbounded preceding and unbounded following) as nv from sm;

-- If a brand has fewer than 3 phones, what is the result of trying to find the 3rd Model_Name using
-- Nth_VALUE() Demonstrate this with a query (assuming a brand like 'ZTE' has only 2 rows).
SELECT Brand_name, Model, Price, NTH_VALUE(Model, 3) over ( order by Price desc ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS Third_Model
from sm where brand_name = 'ZTE' order by Price desc;

-- Find the Nth_VALUE of 2 to identify the second-highest Rating overall.
select brand_name,rating,nth_value(rating,2) over(order by rating desc rows between unbounded preceding and unbounded following) as nv from sm;

-- Write a query to display the Model_Name that ranks 3rd best by Rating for the 'Xiaomi' brand.
select brand_name,model,rating,nth_value(model,3) over(order by rating desc rows between unbounded preceding and unbounded following) as nv from sm where brand_name = 'Xiaomi';

-- What is the average Price of all phones, compared to the Price of the phone that ranks 10th by Rating? Nth_VALUE()  for the 10th phone).
SELECT Brand_name,Model,Price,NTH_VALUE(Price, 10) OVER (
        ORDER BY Rating DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS Price_of_10th_Rated, AVG(Price) OVER () AS Global_Average_Price,(
        NTH_VALUE(Price, 10) OVER ( ORDER BY Rating DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) - AVG(Price) OVER () ) AS Difference_10th_vs_Avg
FROM sm
ORDER BY Rating DESC;

-- Use Nth_value() to display the Brand of the 1st phone when ordered by Price (descending). (This is a good way to test if you can use Nth_VALUE(Brand, 1)$).
SELECT Brand_name,Model,Price, NTH_VALUE(Brand_name, 1) OVER ( ORDER BY Price DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWINg ) AS Brand_Of_Most_Expensive

FROM sm ORDER BY Price DESC;
-- ###############################################################################################################################################################
-- Lag():- 
-- Write a query to show the Price of the previous (alphabetically preceding) Model_Name next to the current phone's price.
select brand_name,price,model,lag(price)over(order by model asc) as lg from sm;

-- Partition the data by Brand and display the Rating of the phone that was rated immediately before the current one (when ordered by rating descending).
select brand_name,rating,lag(rating)over(partition by brand_name order by rating desc) as lg from sm;

-- Calculate the price difference between the current phone and the phone that was two rows before it (offset 2), when ordered by Price descending.
select brand_name,price,lag(price,2)over(order by price desc) as lg_price,
(price - lag(price,2)over(order by price desc)) as diff from sm;

-- For the 'Samsung' brand, show the Model_Name of the phone that came immediately before the current phone, ordered by Model_Name alphabetically.
select brand_name,model,lag(model)over(order by model asc) as lg from sm where brand_name = 'Samsung';

-- Identify all phones whose Rating is higher than the phone immediately preceding it globally (ordered by Price ascending).
with cte as (select brand_name,rating,price,lag(rating)over(order by price)as lg from sm) 
select brand_name,rating,price,lg from cte where rating > lg;

-- Use LAG() to find the Price of the phone exactly 5 positions before the current phone, 
-- partitioned by Brand and ordered by Rating ascending. Use a default value of 0 if the lag
--  value does not exist.
with cte as (select brand_name,price,rating,lag(price,5,0)over(partition by brand_name order by rating) as lg from sm)
select brand_name,price,rating,lg from cte where lg is not null;

-- Find the brand of the phone that was immediately listed before the current phone (ordered by Price ascending).
select brand_name,price,lag(brand_name)over(order by price)as lg from sm;

-- Write a query to compare the current Price with the Price of the phone three rows before it,
-- using a default value of the current phone's price if the lagged price is null.
select brand_name,price,lag(price,3,price)over(order by price) as lg,
(price - lag(price,3,price)over(order by price))as diff from sm;

-- For the entire dataset (no partitioning), find the Rating of the phone one position before 
-- the current one, ordered by Model_Name alphabetically.
select brand_name,model,rating,lag(rating,1) over(order by model)as lg from sm;

-- Use LAG() to calculate the difference in Rating between the current phone and the next phone in the list when ordering by Price descending. (Hint: Lag() with an offset of -1 or a negative order direction can effectively act like LEAD().
select brand_name,price,rating,lag(rating)over(order by price desc) as lg_rating,
(rating - lead(rating, 1)over(order by price desc))as diff from sm;

-- #############################################################################################################################################################
-- Lead():-
-- Write a query to show the Price of the next (alphabetically succeeding) Model_Name next to the current phone's price.
select brand_name,model,price,lead(price)over(order by model) as led from sm;

-- Partition the data by Brand and display the Rating of the phone that will be rated immediately after the current one (when ordered by rating descending).
select brand_name,rating,lead(rating)over(partition by brand_name order by rating) as ld from sm;

-- Calculate the price difference between the current phone and the phone that is two rows afterit (offset 2), when ordered by Price descending.
select brand_name,price,lead(price,2)over(order by price desc) as ld,
(price - lead(price,2)over(order by price desc)) as diff from sm;

-- For the 'Xiaomi' brand, show the Model_Name of the phone that comes immediately after the current phone, ordered by Model_Name alphabetically.
select brand_name,model,lead(model)over(order by model) as ld from sm where brand_name = 'Xiaomi';

-- Identify all phones whose Rating is lower than the phone immediately succeeding it globally(ordered by Price ascending).
with cte as (select brand_name,rating,price,lead(rating)over(order by price)as ld from sm)
select brand_name,rating,price,ld from cte where rating<ld;

-- Use LEAD() to find the Rating of the phone exactly 5 positions after the current phone, partitioned by Brand and ordered by Price ascending. Use a default value of the current phone rating if the lead value does not exist.
select brand_name,rating,price,lead(rating,5,rating)over(partition by brand_name order by price)as ld from sm;

-- Find the brand of the phone that will be immediately listed after the current phone (ordered by Rating descending).
select brand_name,rating,lead(brand_name)over(order by rating desc) as ld from sm;

-- Write a query to compare the current Price with the Price of the phone three rows ahead of it, using a default value of 0 if the lead price is null.
select brand_name,price,lead(price,3,0)over(order by price) as ld, (price - lead(price,3,0)over(order by price))as diff from sm;

-- For the entire dataset (no partitioning), find the Price of the phone one position after the current one, ordered by Rating descending.
select brand_name,price,rating,lead(price,1)over(order by rating desc) as ld from sm;

-- Use LEAD() to calculate the percentage change in Price between the current phone and the 
-- next phone in the list when ordering by Model_Name alphabetically.
select brand_name,model,price,lead(price)over(order by model asc) as ld,
(((lead(price)over(order by model)) - price) /price) * 100 as per_Chnge from sm;

-- #################################################################################################################################################################
-- CUMULATIVE_SUM() and CUMULATIVE_AVG():- 
-- Calculate the running total of price globally, ordered by model alphabetically.
select brand_name,model,price,sum(price) over(order by model rows between unbounded preceding and current row)as cum_sum from sm;

-- Cumulative AVG (Price, Partitioned): -- Find the running average Cumulative_Average of
-- Price for each Brand, ordered by Rating descending.
select brand_name,rating,price,avg(price)over(partition by brand_name order by rating desc)as Cum_Avg from sm;

-- CumulativeSum:- Calculate the Cumulative_Sum of Price globally, but reset the sum to zero whenever a phone's price exceeds 15000. (Hint: Requires an unusual partitioning structure)
with cte as (select brand_name,model,price,sum(case when price > 15000 then 1 else 0 end)
over(order by price,model rows between unbounded preceding and 1 preceding)as group_cum_sum from sm)
select brand_name,price,group_cum_sum,sum(price)over(partition by group_cum_sum order by price,model) as cum_sum from cte;

-- Cumulative_Avg (Global, Filtered): -- Find the Cum_Avg of Price globally, but only considering
-- phones that have a rating of 4.5 or higher, ordered by rating descending. (Hint: Use a case statement inside Avg).
select brand_name,rating,price,avg(price)over(order by rating desc) as cum_avg from sm where rating >= 4.5;
select brand_name,rating,price,avg(case when rating >= 4.5 then price else null end)over(order by rating desc) as cum_avg from sm;

-- Cumulative_Sum of Rating (Partitioned): - Calculate the running total of rating within the 'Samsung' brand only, ordered by price ascending.
select brand_name,rating,sum(rating)over(partition by brand_name order by price rows between unbounded preceding and current row) as cum_sum from sm where brand_name='Samsung'; 

-- Cumulative_Sum (Order by Rating): -- Calculate the Cum_sum of Price globally, ordered by 
-- Rating descending. What is the sum after the first 10 rows?
with cte as (select brand_name,rating,price,sum(price)over(order by rating desc) as cum_sum ,row_number()over(order by rating) as rn from sm )
select brand_name,rating,price,cum_sum from cte where rn = 10;

-- Difference from Cumulative_Sum: -- Display the difference between the current price and the 
-- Price of the phone 5 rows before it, then calculate the Cumulative_Sum of that difference, 
-- ordered by Price descending.
with cte as (select brand_name,price,price - lag(price,5)over(order by price desc) as lg from sm)
select brand_name,price,lg,sum(price)over(order by price desc) as diff from cte;

-- Cumulative_Avg of Rating (Partitioned, Order by Price): -- Calculate the running average of Rating for each 
-- Brand_Name, ordered by Price descending.
select brand_name,price,avg(rating)over(partition by brand_name order by price desc) as cum_Avg from sm;

-- CumulativeSum of Rating (Filtered, Global): -- Calculate the Cumulative_Sum of Rating for all phones, but only 
-- include the Rating in the sum if the phone's Price is less than 8000 (still counting all rows in 
-- the running total), ordered by Price ascending.
select brand_name,Price,rating,sum(case when price < 8000 then rating else null end)over(order by price) as cum_sum from sm;

-- Cumulative Avg of Difference lead: -- Calculate the running average of the difference between the current 
-- Price and the price of the phone 2 positions ahead LEAD, globally ordered by Price ascending.
with cte as ( select brand_name,price,price - lead(price,2)over(order by price) as ld from sm)
select avg(ld) as diff  from cte;

-- ################################################################################################################################################################
-- MOVING_AVG & PERCENT_CHANGE:- 
--  Moving_Avg (3-Point Trailing): -- Calculate the 3-point MA of Price globally (current row and two preceding rows),
-- ordered by Rating ascending. (Hint: Use ROWS BETWEEN 2 PRECEDING AND CURRENT ROW).
select brand_name,rating,price,avg(price)over(order by rating rows between 2 preceding and current row) as MA from sm;

-- Moving_Sum (4-Row Centered): -- Calculate the Moving_Sum of Rating over the two preceding rows, the current row, and
--  the one succeeding row (4-row window), partitioned by Brand and ordered by Model_Name alphabetically.
select brand_name,sum(rating)over(partition by brand_name order by Model rows between 2 preceding and 1 following) as MS from sm;

-- MovingAvg (5-Row Leading): -- Calculate the 5-point MA of Price globally(current row and four succeeding rows), 
-- ordered by Price descending.
select brand_name,price,avg(price)over(order by price desc rows between current row and 4 following) as MA from sm;
 
-- Percent Change Price from LAG: -- Calculate the percentage change in price from the phone 2 positions behind the 
-- current one, globally ordered by price ascending.
select brand_name,price,lag(price,2)over(order by price) as lg,
(((price - lag(price,2)over( order by price)))/lag(price,2)over(order by price)) * 100 as per_Chnge from sm;

-- Percent Change (Rating from LEAD): -- Calculate the percentage change in rating to the phone 3 positions ahead of 
-- the current one, partitioned by Brand and ordered by Rating descending.
with cte as (select brand_name,rating,lead(rating,3)over(partition by brand_name order by rating desc) as ld from sm)
select brand_name,rating,ld,((ld - rating)/rating) * 100 as per_chnge from cte;

-- Moving AVG (Partitioned, 2-Row Trailing): -- Calculate the MA of Price over the current row and the preceding row 
-- (2-row trailing window), partitioned by Brand and ordered by rating descending.
select brand_name,price,rating,avg(price)over(partition by brand_name order by rating desc rows between 1 preceding 
and  current row ) as MA from sm;
